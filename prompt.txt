You are a Math professor and Lead Python Engineer with Polymarket experience. You are expert at mathematical and logical thinking. You write concise, neat and beginner friednly papers. Also, you write clean, safe and efficient code in Python.
Below I have two plans - one for research (for me), one for Github repo which I want to create and showcase my skills in researching, math and coding.
Let's start with how we can automate finding related markets with the help of llms. Research points I alreadt done.

Please update the script below so it also adds prices for yes/no (but i'm not sure how it works if for example question has multiple outcomes), it should contain info enough for LLM to decided which markets are related and if there are any price inefficiencies.

The current script looks like this:
import requests
import json
from datetime import datetime
from typing import List, Dict, Any

def get_compact_market_info(market: Dict[str, Any]) -> Dict[str, Any]:
    """Extract only relevant market information for correlation analysis."""
    return {
        "id": market.get('id'),
        "question": market.get('question'),
        "description": market.get('description'),
        "outcomes": [outcome.get('name') for outcome in market.get('outcomes', [])],
        #"volume": float(market.get('volume', 0)),
        #"endDate": market.get('endDate'),
        #"tags": market.get('tags', []),
        #"category": market.get('category')
    }

def fetch_active_markets(required_tags: List[str] = ["Politics"]) -> List[Dict[str, Any]]:
    """
    Fetch all active markets that contain ALL specified tags.
    
    Args:
        required_tags: List of tags that must all be present in a market
    
    Returns:
        List of markets containing all required tags
    """
    all_markets = []
    next_cursor = ""
    
    while next_cursor != "LTE=":
        url = f"https://clob.polymarket.com/markets"
        if next_cursor:
            url += f"?next_cursor={next_cursor}"
        
        try:
            response = requests.get(url)
            response.raise_for_status()
            data = response.json()
            
            # Filter for active, non-closed markets with ALL required tags
            filtered_markets = [
                get_compact_market_info(market) 
                for market in data.get('data', [])
                if (not market.get('closed', True) 
                    and market.get('active', False)
                    and all(tag in market.get('tags', []) for tag in required_tags))
            ]
            
            all_markets.extend(filtered_markets)
            next_cursor = data.get('next_cursor', "LTE=")
            print(f"Fetched {len(filtered_markets)} markets with tags {required_tags}. Total: {len(all_markets)}")
            
        except requests.exceptions.RequestException as e:
            print(f"Error fetching markets: {e}")
            break
    
    return all_markets

def save_markets_to_file(markets: List[Dict[str, Any]], 
                        filename: str,
                        required_tags: List[str]) -> None:
    """
    Save markets to JSON file with timestamp and tag information.
    
    Args:
        markets: List of market data to save
        filename: Base filename to use
        required_tags: List of tags used to filter markets
    """
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    tags_str = "_".join(required_tags).lower()
    filename = f"{filename}_{tags_str}_{timestamp}.json"
    
    with open(filename, "w") as f:
        json.dump({
            "timestamp": timestamp,
            "required_tags": required_tags,
            "market_count": len(markets),
            "markets": markets
        }, f, indent=2)
    
    print(f"Saved {len(markets)} markets to {filename}")

if __name__ == "__main__":
    # Example usage with multiple tags
    required_tags = ["Ukraine"]  # Markets must have both tags
    markets = fetch_active_markets(required_tags=required_tags)
    save_markets_to_file(markets, "polymarket_markets", required_tags)



Research Points
1. Polymarket fundamentals - platform mechanics, fees, and withdrawal processes
2. Market types available and their structures
3. Order book dynamics and liquidity patterns
4. Arbitrage opportunities across correlated markets
5. Statistical arbitrage methods applicable to prediction markets
6. Historical data availability and access methods
7. Regulatory considerations and limitations
8. Risk management strategies for prediction market arbitrage
9. Tax implications of earnings
Project Structure
1. Introduction
* Problem statement and arbitrage definition
* Polymarket overview
* Project scope and objectives
2. Theoretical Foundation
* Mathematical formulation of arbitrage conditions
* Probability theory for prediction markets
* Fee modeling and impact on profitability
3. Market Analysis
* Data collection methodology
* Analysis of historical arbitrage opportunities
* Market inefficiency patterns
4. Implementation
* Algorithm design
* System architecture
* Trading execution strategy
5. Results & Evaluation
* Performance metrics
* Profitability analysis
* Risk-adjusted returns
6. Conclusion
* Key findings
* Limitations
* Future research directions
7. Code Repository Structure
* Data collection scripts
* Analysis modules
* Trading algorithm implementation
* Visualization tools
* Testing framework